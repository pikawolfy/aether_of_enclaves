extern crate piston_window;

use piston_window::*;

enum Direction{
    Up,
    Down,
    Left,
    Right
}

struct Player {
    x_pos: f64,
    y_pos: f64,
    speed: f64,
}

impl Player {
    fn new() -> Player {
        Player{
            x_pos: 0.0,
            y_pos: 0.0,
            speed: 3.0,
        }
    }

    fn move_player(&mut self, dir: Direction) {
        match dir {
            Direction::Up => self.y_pos -= self.speed,
            Direction::Down => self.y_pos += self.speed,
            Direction::Left => self.x_pos -= self.speed,
            Direction::Right => self.x_pos += self.speed
        }
    }
}

fn main() {
    let mut player = Player::new();

    let mut window: PistonWindow = WindowSettings::new("Hello Piston!", (500, 500))
        .exit_on_esc(true)
        .build()
        .unwrap();

    while let Some(e) = window.next() {
         match e {
            Event::Input(Input::Button(args)) => {
                if args.button == Button::Keyboard(Key::W) { player.move_player(Direction::Up); }
                if args.button == Button::Keyboard(Key::S) { player.move_player(Direction::Down); }
                if args.button == Button::Keyboard(Key::A) { player.move_player(Direction::Left); }
                if args.button == Button::Keyboard(Key::D) { player.move_player(Direction::Right); }
            }

            Event::Loop(Loop::Render(args)) => {
                window.draw_2d(&e, |context, graphics| {
                    clear([0.0, 0.0, 0.0, 1.0], graphics);
                    let red = [1.0, 0.0, 0.0, 1.0];
                    let square = [player.x_pos, player.y_pos, 100.0, 100.0];
                    rectangle(red, square, context.transform, graphics);
                });
            }

            Event::Loop(Loop::Update(args)) => {
                //Update Events
            }
            _ => {}
        }
    }
}
